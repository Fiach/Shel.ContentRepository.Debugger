<?php
declare(strict_types=1);

namespace Shel\ContentRepository\Debugger\Service;

use Doctrine\ORM\EntityManagerInterface;
use Neos\ContentRepository\Domain\Model\NodeData;
use Neos\ContentRepository\Domain\Model\NodeType;
use Neos\ContentRepository\Domain\Service\NodeTypeManager;
use Neos\ContentRepository\Exception\NodeTypeNotFoundException;
use Neos\Flow\Annotations as Flow;

/**
 * @Flow\Scope("singleton")
 */
class NodeTypeGraphService
{

    /**
     * @Flow\Inject
     * @var NodeTypeManager
     */
    protected $nodeTypeManager;

    /**
     * @Flow\InjectConfiguration("defaults")
     * @var array
     */
    protected $defaults;

    /**
     * @Flow\Inject
     * @var EntityManagerInterface
     */
    protected $entityManager;

    /**
     * @param NodeType|null $baseNodeType
     * @param array $parentTypes
     * @param bool $buildGrandChildConstraints
     * @return array
     * @throws NodeTypeNotFoundException
     */
    public function buildConstraintGraph(?NodeType $baseNodeType, array $parentTypes = [], bool $buildGrandChildConstraints = true): array
    {
        if (!$baseNodeType) {
            return [];
        }

        $nodeTypes = $this->nodeTypeManager->getNodeTypes();
        $instantiableNodeTypes = array_filter($nodeTypes, function (NodeType $nodeType) {
            return !$nodeType->isAbstract();
        });

        $directConstraints = [];
        foreach ($this->generateAllowedChildNodeTypes($baseNodeType, $instantiableNodeTypes) as $nodeTypeName) {
            $nodeType = $this->nodeTypeManager->getNodeType($nodeTypeName);
            if (in_array($nodeTypeName, $parentTypes)) {
                $directConstraints[$nodeTypeName] = $nodeTypeName;
            } else {
                $childNodeParentTypes = $parentTypes;
                $childNodeParentTypes[]= $nodeTypeName;
                $directConstraints[$nodeTypeName] = $this->buildConstraintGraph($nodeType, $childNodeParentTypes, $buildGrandChildConstraints);
            }
        }

        $autoGeneratedChildNodeConstraints = [];
        foreach (array_keys($baseNodeType->getAutoCreatedChildNodes()) as $childNodeName) {
            $grandChildNodes = $this->generateAllowedGrandChildNodeTypes($childNodeName, $baseNodeType, $instantiableNodeTypes);
            $autoGeneratedChildNodeConstraints[$childNodeName] = [];
            foreach ($grandChildNodes as $grandChildNodeName) {
                $grandChildNodeType = $this->nodeTypeManager->getNodeType($grandChildNodeName);

                if (!$buildGrandChildConstraints || in_array($grandChildNodeName, $parentTypes)) {
                    $autoGeneratedChildNodeConstraints[$childNodeName][$grandChildNodeName] = $grandChildNodeName;
                } else {
                    $childNodeParentTypes = $parentTypes;
                    $childNodeParentTypes[]= $grandChildNodeName;
                    $autoGeneratedChildNodeConstraints[$childNodeName][$grandChildNodeName] = $this->buildConstraintGraph($grandChildNodeType, $childNodeParentTypes, false);
                }
            }
        }

        return [
            'directConstraints' => $directConstraints,
            'autoGeneratedChildNodeConstraints' => $autoGeneratedChildNodeConstraints,
        ];
    }

    /**
     * Returns the list of all allowed subnodetypes of the given node
     *
     * @param NodeType $baseNodeType
     * @param array $nodeTypes
     * @return array
     */
    public function generateAllowedChildNodeTypes(NodeType $baseNodeType, array $nodeTypes): array
    {
        return array_reduce($nodeTypes, function (array $carry, NodeType $nodeType) use ($baseNodeType) {
            if ($baseNodeType->allowsChildNodeType($nodeType)) {
                $carry[] = $nodeType->getName();
            }
            return $carry;
        }, []);
    }

    /**
     * Returns the list of all allowed subnodetypes of the given nodes child
     *
     * @param string $childName
     * @param NodeType $baseNodeType
     * @param array $nodeTypes
     * @return array
     */
    public function generateAllowedGrandChildNodeTypes(
        string $childName,
        NodeType $baseNodeType,
        array $nodeTypes
    ): array {
        return array_reduce($nodeTypes, function (array $carry, NodeType $nodeType) use ($baseNodeType, $childName) {
            try {
                if ($baseNodeType->allowsGrandchildNodeType($childName, $nodeType)) {
                    $carry[] = $nodeType->getName();
                }
            } catch (\InvalidArgumentException $e) {
                // Skip non autogenerated child nodes
            }
            return $carry;
        }, []);
    }

    /**
     * Return the usage count of each nodetype in the content repository
     *
     * @return array
     */
    public function getNodeTypeUsageQuery(): array
    {
        $qb = $this->entityManager->createQueryBuilder();
        $nodeTypeUsage = $qb->select('n.nodeType, COUNT(n.identifier) as count')
            ->from(NodeData::class, 'n')
            ->groupBy('n.nodeType')
            ->andWhere('n.removed = false')
            ->getQuery()
            ->getScalarResult();

        $nodeTypes = array_column($nodeTypeUsage, 'nodeType');
        $usageCount = array_column($nodeTypeUsage, 'count');

        return array_combine($nodeTypes, $usageCount);
    }
}
